// CALLUM KOH IS HERE TO SAVE THE DAY! // PUZZLEE QUEST! ¯\_(ツ)_/¯  // for sqrt#include <math.h>// for assert#include <assert.h>// for malloc#include <stdlib.h>#include <stdio.h>#include "mandelbrot.h"#include "pixelColor.h"#define MAX_ITERATION 256#define SIZE 512#define BYTES_PER_PIXEL 3// bits that define BMP size// 0-1: BM// Size: 786486 bytes, C0036 HEX, stored in LITTLE endian// static const bits8 bmpHeader[] = {    0x42, 0x4D, 0x36, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00,    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x13, 0x0B, 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00, 0x00, 0x00, 0x00};// size of headerconst int bmpHeaderSize = sizeof(bmpHeader);// size of whole BMPconst int bmpSize = (SIZE * SIZE * BYTES_PER_PIXEL) + sizeof(bmpHeader); // Here's my "escapeSteps" function. It passes all the test cases on mandelbrotTest.c!int escapeSteps(double x, double y) {  int steps = 1;  double originalX = x;  double originalY = y;  double newY;  double newX;    while (steps < MAX_ITERATION && sqrt((x*x + y*y)) <= 2) { // make sure that steps < max and the modulus is <= 2      newX = (x * x) - (y * y) + originalX;       newY = (2.0 * x * y) + originalY;      x = newX;      y = newY;      steps++;  }  return steps;}// Generates a mandelbrot image, returning bits8 *mandleBrotByteArray(double x, double y, int zoom) {  bits8 *outputArray = (bits8*) malloc(bmpSize);    int count = 0;  while (count < bmpHeaderSize) {    outputArray[count] = bmpHeader[count];    count++;  }    double pixelSize = pow(2, -zoom);  // set this to bottom left  // x is the middle  double pixelX = x - (SIZE/2 * pixelSize);  double pixelY = y - (SIZE/2 * pixelSize);    int colsWritten = 0;  int rowsWritten = 0;    while (rowsWritten < SIZE) {    while (colsWritten < SIZE) {#ifdef DEBUG      printf("x coordinate: %lf, y coordinate: %lf, excaped: %d \n", pixelX, pixelY, escapeSteps(pixelX, pixelY));#endif            int stepsRequired = escapeSteps(pixelX, pixelY);      outputArray[count] = stepsToBlue(stepsRequired);      count++;      outputArray[count] = stepsToGreen(stepsRequired);      count++;      outputArray[count] = stepsToRed(stepsRequired);      count++;            pixelX += pixelSize;      colsWritten++;    }    rowsWritten++;    colsWritten = 0;    pixelX = x - (pixelSize/2 + 255 * pixelSize);    pixelY += pixelSize;  }  return outputArray;} 